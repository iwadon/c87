# Shellshock

多くのLinuxシステムでデフォルトシェルとなっている**bash**に、
環境変数を通して任意のコマンドが実行できる脆弱性が見つかった。
いわゆるコマンドインジェクションというものである。

## 概要

環境変数の設定で関数定義に続く形でコマンドが書かれた場合、
bashがそのコマンドが実行してしまうバグがあった。
例えば次のようなコマンドで

    env x='() { :;}; echo vulnerable' bash -c "echo this is a test"

脆弱性が存在する場合、 `echo vulnerable` が実行されて

    valnerable
    this is a test

と出力される。

単純にこの動作だけでは脆弱性と言い切れるかどうか微妙だが、
**CGIがリクエストの情報を環境変数として持つ**、
**/bin/shが実はbashのエイリアスなLinuxが多い**という特徴により、
問題はより大きくなり完全に脆弱性となった。
例えば`HTTP_USER_AGENT`ヘッダに`() { :;}; cat /etc/passwd`という文字列を設定してリクエストすると、サーバ上で`cat /etc/passwd`が動いてしまう。
直接bashでCGIを書いてなくても、各プログラミング言語の**system関数**あたりを使ってしまうとアウトに場合がある。
ただし`/bin/sh`の実体がbashではない場合問題にはならない。

これはheartbleedより遥かに強烈で、CGIユーザの実行権限がある範囲では何でもできてしまう。
より直接性の高い攻撃が可能だ。

例えば以下のような方法で確実性を持って証明書や秘密鍵を盗むことが可能だ。

1. `() { :;}; cat /etc/nginx/nginx.conf` でnginxの設定ファイルを読む
1. 設定ファイルに書かれたssl証明書のありかを `() { :;}; cat /path/to/cert` で読む

heartbleedは運が必要だったがこの攻撃方法に運は必要ない。
Linuxの設定ファイルがだいたい同じルールに従って置かれていることも攻撃を簡単にする。

任意のコマンドが実行可能なので、サーバにデプロイされたコードを読むことも書き変えることもできる。
不正なソフトウェアを動かしバックドアを仕掛けることもできるし、別の攻撃の踏み台にすることも可能だ。
ユーザ権限でCGIを動かしていて、そのユーザがsudoersでNOPASSWDなんかに設定されていた場合はもう手の施しようがない。
完全に死だ。
